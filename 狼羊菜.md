# 基于Javascript的狼羊菜过河问题分析及解决方案
## 1.问题描述：
一个农夫带着一只狼、一只羊和一棵白菜，身处河的左岸。他要把这些东西全部运到河对面右岸。河边只有一条小船，小船只能容下一个人和一件物品，另外只有农夫才能撑船。如果农夫在场，则狼不能吃羊，羊不能吃白菜，否则狼会吃羊，羊会吃白菜，所以农夫不能留下羊和白菜自己离开，也不能留下狼和羊自己离开，而狼不吃白菜。请求出农夫将所有的东西运过河的可行的最优方案。
## 2.问题分析及解决思路
农夫狼羊菜过河问题，左岸的农夫、狼、羊、菜，以指定的方式过河，最终全部成员达到右岸。  
左岸的初始状态是：农夫、狼、羊、菜四个成员，如果成员存在，状态码标记为1；如果某成员不存在则标记为0；初始状态码为：1111。  
当四个成员都达到右岸后，左岸状态为：农夫、狼、羊、菜四个成员都不存在，状态码为：0000。
- 构造状态码  
以左岸状态码为基准参考，由初始状态的1111到终止状态的0000，根据计算机编码1111~~0000共有16种状态：  
（1111,1110,1101,1100,1011,1010,1001,1000,0111,0110,0101,0100,0011,0010,0001,0000）.
- 排除不安全状态   
根据题目已知信息，农夫、狼、羊、菜四个成员之间存在不安全状态，即：农夫不在时，狼吃羊，羊吃菜；  
在16个状态码中需要去除不安全状态码。即农夫为0时，狼羊为1或羊菜为1；农夫为1时，狼羊为0或羊菜为0；    
由此，不安全状态码有：0111,0110,0011；1000,1001,1100 .一共6个状态。
- 安全状态下规划路径  
至此，安全的状态码共有10个。
>1111：[农夫、狼、羊、菜]  
>1110：[农夫、狼、羊]  
>1101：[农夫、狼、菜]  
>1011：[农夫、羊、菜]  
>1010：[农夫、羊]  
>0101：[狼、菜]  
>0100：[狼]  
>0010：[羊]  
>0001：[菜]  
>0000：[]

	基于此10个安全状态，规划路径由1111到0000，记录不重复状态构造路径，以此解决问题。  
- 过河动作分解：从左岸到右岸，从右岸到左岸 
  + 从左岸到右岸  
	* 农夫必须离开：农夫状态码为0
	* 农夫必须带一个成员离开：每次减少2个成员
	* 剩余的成员必须在未离开之前的成员中：原状态成员包含现有成员
	* 当前状态码不在已有路径中：状态不重复
  + 从右岸到左岸  
	* 农夫必须回来：农夫状态码为1  
	* 现有成员必须包含之前成员：现有成员包含原成员
	* 当前状态码不在已有路径中：状态不重复

	每次过河之后，将状态码保存到路径中，直到状态码为0000时，将路径保存为结果。  
- 输出结果
根据得到的结果集，

## 3.Javascript编程解决方案
- ### *Javascript编程基础(ES6)*
 * 数组的扩展
 * 箭头函数
 * Map数据结构
 * 
- 设置基本成员常量：  
```Javascript
	const items = ["农夫", "狼", "羊", "菜"] //所有成员清单 常量
```
- 设置相关变量： 
```Javascript
	var start = "1111", //以左岸为例,初始状态
		end = "0000", //终止状态
		states , //所有状态,输出打印时用于求成员之间的变动
		states_safe, //安全状态,排除安全隐患.用于规划路径
		stack = [], //规划路径
		Result = [], //最终路径:长度最短的合法路径
		res_min //合理规划路径的长度,只保存最短路径
```
- 构造基本状态：从1111~~0000的16种状态，包含成员信息的map结构。   
如：
>{  
>	"1111" => ["农夫", "狼", "羊", "菜"],   
>	"1110" => ["农夫", "狼", "羊"],   
>	"1101" => ["农夫", "狼", "菜"],   
>	…  
>}  

 ```Javascript
	states = new Map( //构造状态码及成员信息,map结构:key为状态码，value为成员.(将二维数组转换为map)
		new Array(16).fill(0).map((n, i) => (s_key = (15-i).toString(2).padStart(4, "0"), //构造状态码数组
		[s_key, [...s_key].map((n, i) => n * 1 && items[i]).filter(n => n != 0)])) //映射成员信息:二维数组
	)
```
- 设置安全状态检测，筛选出安全状态码。 
```Javascript
	states_safe = new Map([...states].filter(([s_key, s_value]) => isSafe(s_value))) //从states筛选安全状态
	function isSafe(s_item) { //安全状态检测函数：检测数组s_item的成员是否安全
		let isHere = [...items].map(n => s_item.includes(n)) //四个成员的存在状态
		let unSafe1 = !isHere[0] && (isHere[2] && (isHere[1] || isHere[3])), //农夫不时：狼和羊,羊和菜
			unSafe2 = isHere[0] && (!isHere[2] && (!isHere[1] || !isHere[3])) //农夫在时: 狼羊不在,羊菜不在
		return !(unSafe1 || unSafe2) //排除两个不安全状态
	}
```
- 构造过河函数，获取合理结果：   
过河操作：首先将初始状态添加到路径。`stack.push(start)`   
从左岸到右岸时：  
遍历10个安全状态，根据当前成员s_item判断4个条件（1.农夫不在，2.成员减少两个，3.当前成员属于原成员，4.未在规划路径中），
如果成立则将当前状态码添加到路径，并执行下一次过河动作：从右岸到左岸。   
从右岸到左岸：
遍历10个安全状态，根据当前成员s_item判断3个条件（1.农夫须在，2.当前成员包含原成员，3.未在规划路径中），
如果成立则将当前状态码添加到路径，并执行下一次过河动作：从左岸到右岸。
直到左岸状态为终止状态，则将路径保存到结果记录集中，继续执行直至遍历所有分支节点方案。
深度搜索完成之后，删除路径中最后一个状态码，执行回退，以便进行分支求解。
```Javascript
	function Move(s_key, L2R) { //农夫过河操作:s_key为左岸状态码,L2R为bool值:从左到右？从右到左
		if (s_key == start) stack.push(start) //将初始状态加入路径
		if (s_key == end) { //如果左岸状态码为终止状态,则记录合法路径
			var Stack = [...stack] //记录当前合法路径
			console.log(Stack.map(n => [n, states.get(n)]))
			if (Result.length == 0) { //首次记录结果
				Result.push(Stack)
				result_size = Stack.length //首次合法路径长度
			} else if (Stack.length < result_size) { //当前路径长度小于已存在的合法路径长度
				result_size = Stack.length
				Result = [Stack] //重置记录结果，保存最小长度的合法路径
			} else if (Stack.length == result_size) {
				Result.push(Stack)
			}
			return
		}
		if (L2R) { //从左岸到右岸
			states_safe.forEach((sv, sk) => {
				let r1 = !(sv.includes(items[0])), //农夫必须离开
					r2 = (sv.length == (states_safe.get(s_key).length - 2)), //每次减少2成员
					r3 = AhasB(s_key, sk), //剩余成员必须属于原有成员中
					r4 = !(stack.includes(sk)) //不重复状态:本次状态不在已规划状态路径中
				if (r1 && r2 && r3 && r4) {
					stack.push(sk) //将此状态添加到路径
					Move(sk, false) //根据此状态进行从右到左操作
					stack.pop() //回退，任务完成后清除已规划路径节点,以进行分支求解
				}
			})
		} else { //从右岸到左岸
			states_safe.forEach((sv, sk) => {
				let r1 = sv.includes(items[0]), //农夫必须回去
					r2 = AhasB(sk, s_key), //包含原有成员
					r3 = !(stack.includes(sk)) //不重复状态:本次状态不在已规划状态路径中
				if (r1 && r2 && r3) {
					stack.push(sk) //将此状态添加到路径
					Move(sk, true) //根据此状态进行从右到左操作
					stack.pop() //任务完成后清除已规划路径节点,以进行分支求解
				}
			})
		}

		function AhasB(key_a, key_b) { //检测状态码,key_a是否包含key_b
			let key_c = parseInt(key_a, 2) & parseInt(key_b, 2)
			return key_c == parseInt(key_b, 2)
		}
	}
```
执行过河函数 `Move(start,true)` ,得到结果集:  
>Result(2) [Array(8), Array(8)]  
>>0: (8) ["1111", "0101", "1101", "0100", "1110", "0010", "1010", "0000"]  
>>1: (8) ["1111", "0101", "1101", "0001", "1011", "0010", "1010", "0000"]  
- 输出结果：